//xlang Source, Name:QPainter.xcsm
//Date: Mon Oct 21:05:42 2018
package Qt{

    public class QPainter {

        public long hpaint;
        bool bneed_delloc = false;

        public static class RenderHint {
            public static const int
            Antialiasing = 0x01,
            TextAntialiasing = 0x02,
            SmoothPixmapTransform = 0x04,
            HighQualityAntialiasing = 0x08,
            NonCosmeticDefaultPen = 0x10,
            Qt4CompatiblePainting = 0x20;
        };

        public enum CompositionMode {
            CompositionMode_SourceOver,
            CompositionMode_DestinationOver,
            CompositionMode_Clear,
            CompositionMode_Source,
            CompositionMode_Destination,
            CompositionMode_SourceIn,
            CompositionMode_DestinationIn,
            CompositionMode_SourceOut,
            CompositionMode_DestinationOut,
            CompositionMode_SourceAtop,
            CompositionMode_DestinationAtop,
            CompositionMode_Xor,

            //svg 1.2 blend modes
            CompositionMode_Plus,
            CompositionMode_Multiply,
            CompositionMode_Screen,
            CompositionMode_Overlay,
            CompositionMode_Darken,
            CompositionMode_Lighten,
            CompositionMode_ColorDodge,
            CompositionMode_ColorBurn,
            CompositionMode_HardLight,
            CompositionMode_SoftLight,
            CompositionMode_Difference,
            CompositionMode_Exclusion,

            // ROPs
            RasterOp_SourceOrDestination,
            RasterOp_SourceAndDestination,
            RasterOp_SourceXorDestination,
            RasterOp_NotSourceAndNotDestination,
            RasterOp_NotSourceOrNotDestination,
            RasterOp_NotSourceXorDestination,
            RasterOp_NotSource,
            RasterOp_NotSourceAndDestination,
            RasterOp_SourceAndNotDestination,
            RasterOp_NotSourceOrDestination,
            RasterOp_SourceOrNotDestination,
            RasterOp_ClearDestination,
            RasterOp_SetDestination,
            RasterOp_NotDestination
        };

        public static class Paint {
            public static const int
            FILL = 2,
            STROKE = 1,
            FILL_AND_STROKE = 3;
            public int style;
            public int color;
            public double width;
            public int textSize = -1;

            public void setColor(int c) {
                color = c;
            }

            public void setTextSize(double ts) {
                textSize = ts;
            }

            public void setAlpha(int a) {
                color = ((a & 0xff) << 24) | (color & 0x00ffffff);
            }

            public void setStrokeWidth(double sw) {
                width = sw;
            }

            public void setStyle(int s) {
                style = s;
            }
        };

        public enum PenStyle {
            /** @pen style

            */
            NoPen,
            SolidLine,
            DashLine,
            DotLine,
            DashDotLine,
            DashDotDotLine,
            CustomDashLine,
            MPenStyle
        };
        /** @bgm mode

        */
        public static class BackgroundMode {
            static const int
            TransparentMode = 0,
            OpaqueMode = 1;
        };


        /** @ImageConversionFlag
        */
        public static class ImageConversionFlag {

            static const int
            ColorMode_Mask          = 0x00000003,
            AutoColor               = 0x00000000,
            ColorOnly               = 0x00000003,
            MonoOnly                = 0x00000002,
            // Reserved             = 0x00000001,

            AlphaDither_Mask        = 0x0000000c,
            ThresholdAlphaDither    = 0x00000000,
            OrderedAlphaDither      = 0x00000004,
            DiffuseAlphaDither      = 0x00000008,
            NoAlpha                 = 0x0000000c, // Not supported

            Dither_Mask             = 0x00000030,
            DiffuseDither           = 0x00000000,
            OrderedDither           = 0x00000010,
            ThresholdDither         = 0x00000020,
            // ReservedDither       = 0x00000030,

            DitherMode_Mask         = 0x000000c0,
            AutoDither              = 0x00000000,
            PreferDither            = 0x00000040,
            AvoidDither             = 0x00000080,

            NoOpaqueDetection       = 0x00000100,
            NoFormatConversion      = 0x00000200;
        };

        public QPainter(long handle) {
            hpaint = handle;
        }

        public QPainter(@NotNilptr QImage img) throws IllegalArgumentException{
            hpaint = QtXnl.long_get(img.himage, Constant.PAINTERFROMIMG);
            if (hpaint == 0) {
                throw new IllegalArgumentException("paint is null");
            }
            bneed_delloc = true;
        }
        public QPainter(@NotNilptr QPaintDevice device) throws IllegalArgumentException {
            hpaint = QtXnl.long_get(device.nativehandle, Constant.PAINTERFROMDEVICE);
            if (hpaint == 0) {
                throw new IllegalArgumentException("paint is null");
            }
            bneed_delloc = true;
        }
        public void setPaint(@NotNilptr Paint p) {
            if ((p.style & Paint.FILL) != 0) {
                setBrush(p.color, QBrush.Style.SolidPattern);
            }

            if ((p.style & Paint.STROKE) != 0) {
                setPen(p.color, PenStyle.SolidLine, p.width);
            }

            if (p.textSize >0 ) {
                setFontPixelSize(p.textSize);
            }
        }

        public void setFontPointSize(int size) {
            QtXnl.widget_set_vint_value(hpaint, Constant.PAINTFONTPTSIZE, size);
        }

        public void setFontPixelSize(int size) {
            QtXnl.widget_set_vint_value(hpaint, Constant.PAINTFONTPXSIZE, size);
        }

        public void setPen(int color, PenStyle penStyle, double width) {
            QtXnl.widget_set_v2int_double_value(hpaint, Constant.SETPEN, color, width, penStyle);
        }

        public void setBrush(int color, QBrush.Style brushStyle) {
            QtXnl.widget_set_v2int_value(hpaint, Constant.SETBRUSH, color, brushStyle);
        }

        public void setBrush(@NotNilptr QBrush brush) {
            QtXnl.widget_set_native_value(hpaint, Constant.SETBRUSH, brush.nativehandle);
        }

        public void drawLine(int start_x, int start_y, int end_x, int end_y) {
            QtXnl.native_int4(hpaint, Constant.QXPAINTDRAWLINE, start_x, start_y, end_x, end_y);
        }

        public void drawRect(int x, int y, int w, int h) {
            QtXnl.native_int4(hpaint, Constant.QXPAINTDRAWRECT, x, y, w, h);
        }

        public void drawRect(@NotNilptr QRect r) {
            QtXnl.native_int4(hpaint, Constant.QXPAINTDRAWRECT, r.left, r.top, r.width(), r.height());
        }

        public void fillRect(int x,int y, int w,int h, int color, int brushStyle) {
            QtXnl.long_long_int9(hpaint, Constant.FILLRECT, 0, x, y, w, h, color, brushStyle, 0, 0, 0);
        }

        public void save() {
            QtXnl.widget_slot(hpaint, Constant.PAINTERSAVE);
        }

        public void restore() {
            QtXnl.widget_slot(hpaint, Constant.PAINTERRESTORE);
        }

        public void resetMatrix() {
            QtXnl.widget_slot(hpaint, Constant.PAINTRESETMATRIX);
        }

        public QMatrix getMatrix() {
            return new QMatrix(QtXnl.long_get(hpaint, Constant.PAINTERGETMATRIX));
        }

        public void setMatrix(@NotNilptr QMatrix m) {
            QtXnl.widget_set_native_value(hpaint, Constant.PAINTSETMATRIX, m.nativehandle);
        }

        public void resetTransform() {
            QtXnl.widget_slot(hpaint, Constant.PAINTRESETTRANSFORM);
        }

        public void drawText(String text, int x,int y) {
            QtXnl.widget_set_intintstring_value(hpaint, Constant.DRAWTEXT, x, y,text);
        }

        public void drawText(String text, int x,int y, Paint p) {
            if (p != nilptr) {
                setPen(p.color, PenStyle.SolidLine, p.width);
            }
            QtXnl.widget_set_intintstring_value(hpaint, Constant.DRAWTEXT, x, y,text);
        }

        public void fillRect(@NotNilptr QRect r, int color, int brushStyle) {
            QtXnl.long_long_int9(hpaint, Constant.FILLRECT, 0, r.left, r.top, r.width(), r.height(), color, brushStyle, 0, 0, 0);
        }

        public void drawLines(@NotNilptr int [] points)  throws IllegalArgumentException{
            if ((points.length & 1) == 1 || points.length < 4) {
                throw new IllegalArgumentException("points length must be Even numbers");
            }
            QtXnl.array_int2(hpaint, Constant.QXPAINTDRAWLINE, points, 0, 0);
        }

        public void setBackgroundBrush(int color, int brushStyle) {
            QtXnl.widget_set_v2int_value(hpaint, Constant.SETBKBRUSH, color, brushStyle);
        }

        public void setOpacity(double fopacity) {
            QtXnl.widget_set_double_value(hpaint, Constant.QXPAINTOPACITY, fopacity);
        }

        public void setBackMode(int mode) {
            QtXnl.widget_set_vint_value(hpaint, Constant.QXPAINTBGMMODE, mode);
        }

        public void drawImage(@NotNilptr QImage image, @NotNilptr QRect dest, @NotNilptr QRect source, int converFlags) {
            QtXnl.long_long_int9(hpaint, Constant.DRAWIMAGE, image.himage,
                                    dest.left, dest.top, dest.width(), dest.height(),
                                    source.left, source.top, source.width(), source.height(),
                                    converFlags);
        }

        public void drawImage(@NotNilptr QImage image, int x,int y) {
            QtXnl.widget_set_intlongint_value(hpaint, Constant.DRAWIMAGE, image.himage,x, y);
        }

        public void drawRoundRect(int x,int y, int w,int h, int rx, int ry, Paint p) {
            if (p != nilptr) {
                setPaint(p);
            }
            QtXnl.long_long_int9(hpaint, Constant.ROUNDRECT, 0, x, y, w, h, rx, ry, 0, 0, 0);
        }

        public void drawRoundedRect(int x,int y, int w,int h, int rx, int ry, Paint p) {
            if (p != nilptr) {
                setPaint(p);
            }
            QtXnl.long_long_int9(hpaint, Constant.ROUNDEDRECT, 0, x, y, w, h, rx, ry, 0, 0, 0);
        }

        public void drawRoundRect(@NotNilptr QRect r, int rx, int ry, Paint p) {
            if (p != nilptr) {
                setPaint(p);
            }
            QtXnl.long_long_int9(hpaint, Constant.ROUNDRECT, 0, r.left, r.top, r.width(), r.height(), rx, ry, 0, 0, 0);
        }

        public void drawRoundedRect(@NotNilptr QRect r, int rx, int ry, Paint p) {
            if (p != nilptr) {
                setPaint(p);
            }
            QtXnl.long_long_int9(hpaint, Constant.ROUNDEDRECT, 0, r.left, r.top, r.width(), r.height(), rx, ry, 0, 0, 0);
        }

        public void drawPath(@NotNilptr QPath path) {
            QtXnl.widget_set_native_value(hpaint, Constant.DRAWPATH, path.nativehandle);
        }

        public void rotate(double r, double cx, double cy) {
            QMatrix m = getMatrix();
            if (m != nilptr){
                m.translate(cx, cy);
                m.rotate(r);
                m.translate(-cx, -cy);
                setMatrix(m);
            }
        }

        public void translate(double cx, double cy) {
            QMatrix m = getMatrix();
            if (m != nilptr){
                m.translate(cx, cy);
                setMatrix(m);
            }
        }
        public int ascent() {
            return QtXnl.widget_get_int_value(hpaint, Constant.PAINTFONTASCENT);
        }
        public int descent() {
            return QtXnl.widget_get_int_value(hpaint, Constant.PAINTFONTDESCENT);
        }
        public void setCompositionMode(CompositionMode flag) {
            QtXnl.widget_set_int_bool_value(hpaint, Constant.SETCOMPOSITIONMODE, flag, false);
        }

        public void setRenderHint(int flag, bool on) {
            QtXnl.widget_set_int_bool_value(hpaint, Constant.SETRENDERHINT, flag, on);
        }

        public QFont getFont() {
            return new QFont(QtXnl.long_get(hpaint, Constant.PAINTERGETFCONT));
        }

        public void setFont(@NotNilptr QFont f) {
            QtXnl.widget_set_native_value(hpaint, Constant.PAINTERSETFONT, f.nativehandle);
        }

        public void setAntialiasing(bool ba) {
            setRenderHint(RenderHint.Antialiasing, ba);
        }
 
        public void drawCircle(int x,int y,int r, Paint p) {
            if (p != nilptr) {
                setPaint(p);
            }

            QtXnl.native_int4(hpaint, Constant.DRAWELLIPSE, x - r, y - r, r *2, r * 2);
        }

        public @NotNilptr  QRect measureText(int x, int y, String text) {
            long pt= QtXnl.long_longstring(hpaint, Constant.PAINTMEASURETEXT, 0, text);
            return new QRect(x, y, x + ((int)(pt >> 32) & 0xffffffff), y + (int)(pt & 0xffffffff));
        }

        public void finalize() {
            if (bneed_delloc) {
                QtXnl.widget_slot(hpaint, Constant.DELLOCPAINTER);
                bneed_delloc = false;
            }
        }
    };
};