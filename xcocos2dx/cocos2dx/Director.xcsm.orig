//xlang Source, Name:cocos2dx/CCDirector.xcsm 
//Date: Mon Aug 15:59:38 2019 
package Cocos2dx{
    class Director : CCCore{
    
        enum MATRIX_STACK_TYPE
        {
            // Model view matrix stack
            MATRIX_STACK_MODELVIEW,
            
            // projection matrix stack
            MATRIX_STACK_PROJECTION,
            
            // texture matrix stack
            MATRIX_STACK_TEXTURE
        };
        
        static Director getInstance(){
            Director dir = new Director();
            dir.hcore = CCNative.create_xxobject(CCNative.NATIVE_SYSCALL_ID.CC_GETINSTANCE, dir, CC_OBJECT_TYPE.CC_OBJ_DIRECTOR);
            return dir;
        }
        
        Size getVisibleSize() {
            double [] data = (double [])CCNative.xcocox_obj_get(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETVS);
            return new Size(data[0], data[1]);
        }
        
        Vec2 getVisibleOrigin(){
            double [] data = (double [])CCNative.xcocox_obj_get(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETVO);
            return new Vec2(data[0], data[1]);
        }
        
        Rect getSafeAreaRect(){
            double [] data = (double [])CCNative.xcocox_obj_get(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETSAR);
            return new Rect(data[0], data[1], data[2], data[3]);
        }
        
        Vec2 convertToGL(Vec2 pt){
            double [] p = {pt.x, pt.y};
            return new Vec2( (double [])CCNative.xcocox_obj_get_obj(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRCVTGL, p));
        }
        
        Vec2 convertToUI(Vec2 pt){
            double [] p = {pt.x, pt.y};
            return new Vec2((double [])CCNative.xcocox_obj_get_obj(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRCVTUI, p));
        }
        
        double getZEye(){
            return CCNative.xcocox_get_double(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETZE);
        }
        
        void runWithScene(Scene scene){
            CCNative.xcocox_void_func_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRRUNSCENE, scene.hcore);
        }

        /** 
         * Suspends the execution of the running scene, pushing it on the stack of suspended scenes.
         * The new scene will be executed.
         * Try to avoid big stacks of pushed scenes to reduce memory allocation. 
         * ONLY call it if there is a running scene.
         */
        void pushScene(Scene scene){
            CCNative.xcocox_void_func_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPUSHSCENE, scene.hcore);
        }

        /** 
         * Pops out a scene from the stack.
         * This scene will replace the running one.
         * The running scene will be deleted. If there are no more scenes in the stack the execution is terminated.
         * ONLY call it if there is a running scene.
         */
        void popScene(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPOPSCENE);
        }

        /** 
         * Pops out all scenes from the stack until the root scene in the queue.
         * This scene will replace the running one.
         * Internally it will call `popToSceneStackLevel(1)`.
         */
        void popToRootScene(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPOPTOROOTSCENE);
        }

        /** Pops out all scenes from the stack until it reaches `level`.
         If level is 0, it will end the director.
         If level is 1, it will pop all scenes until it reaches to root scene.
         If level is <= than the current stack level, it won't do anything.
         */
        void popToSceneStackLevel(int level){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPOPTOROOTSCENESTACKLEVEL, level);
        }

        /** Replaces the running scene with a new one. The running scene is terminated.
         * ONLY call it if there is a running scene.
         * @js NA
         */
        void replaceScene(Scene scene){
            CCNative.xcocox_void_func_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRREPLACESCENE, scene.hcore);
        }

        /** Ends the execution, releases the running scene.
         * @lua endToLua
         */
        void end(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIREND);
        }

        /** Pauses the running scene.
         * The running scene will be _drawed_ but all scheduled timers will be paused.
         * While paused, the draw rate will be 4 FPS to reduce CPU consumption.
         */
        void pause(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPAUSE);
        }

        /** Resumes the paused scene.
         * The scheduled timers will be activated again.
         * The "delta time" will be 0 (as if the game wasn't paused).
         */
        void resume(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRRESUME);
        }
        
        /*
         * Restart the director. 
         * @js NA
         */
        void restart(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRRESTART);
        }

        /** Stops the animation. Nothing will be drawn. The main loop won't be triggered anymore.
         * If you don't want to pause your animation call [pause] instead.
         */
        void stopAnimation(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSTOPANI);
        }

        /** The main loop is triggered again.
         * Call this function only if [stopAnimation] was called earlier.
         * @warning Don't call this function to start the main loop. To run the main loop call runWithScene.
         */
        void startAnimation(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSTARTANI);
        }

        /** Draw the scene.
         * This method is called every frame. Don't call it manually.
         */
        void drawScene(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRDRAWSCENE);
        }

        // Memory Helper

        /** Removes all cocos2d cached data.
         * It will purge the TextureCache, SpriteFrameCache, LabelBMFont cache
         * @since v0.99.3
         */
        void purgeCachedData(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPURGECACHEDDATA);
        }

        /** Sets the default values based on the Configuration info. */
        void setDefaultValues(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETDEFAULTVALUES);
        }

        // OpenGL Helper

        /** Sets the OpenGL default values.
         * It will enable alpha blending, disable depth test.
         * @js NA
         */
        void setGLDefaultValues(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETGLDEFAULTVALUES);
        }

        /** Enables/disables OpenGL alpha blending. */
        void setAlphaBlending(bool on){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETALPHABLENDING, on ? 1 : 0);
        }
        
        /** Sets clear values for the color buffers,
         * value range of each element is [0.0, 1.0].
         * @js NA
         */
        void setClearColor(Color4F clearColor){
            double [] c4f = {clearColor. r, clearColor.g, clearColor.b, clearColor.a};
            CCNative.xcocox_obj_get_obj(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETCLEARCOLOR, c4f);
        }

        /** Gets clear values for the color buffers.
         * @js NA
         */
        Color4F getClearColor(){
            return new Color4F((double[])CCNative.xcocox_obj_get(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETCLEARCOLOR));
        }

        /** Enables/disables OpenGL depth test. */
        void setDepthTest(bool on){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETDEPTHTEST, on ? 1 : 0);
        }

        void mainLoop(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRMAINLOOP);
        }
        /** Invoke main loop with delta time. Then `calculateDeltaTime` can just use the delta time directly.
         * The delta time paseed may include vsync time. See issue #17806
         * @since 3.16
         */
        void mainLoop(double dt){
            CCNative.xcocox_void_double_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRMAINLOOP, dt);
        }

        /** The size in pixels of the surface. It could be different than the screen size.
         * High-res devices might have a higher surface size than the screen size.
         * Only available when compiled using SDK >= 4.0.
         * @since v0.99.4
         */
        void setContentScaleFactor(double scaleFactor){
            CCNative.xcocox_void_double_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETCONTENTSCALEFACTOR, scaleFactor);
        }
        /**
         * Gets content scale factor.
         * @see Director::setContentScaleFactor()
         */
        double getContentScaleFactor()  { 
            return CCNative.xcocox_get_double(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETCONTENTSCALEFACTOR);
        }

        /** Gets the Scheduler associated with this director.
         * @since v2.0
         */
        Scheduler getScheduler()  { 
            return new Scheduler(CCNative.xcocox_long_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETSCHEDULER));
        }
        
        /** Sets the Scheduler associated with this director.
         * @since v2.0
         */
        void setScheduler(Scheduler scheduler){
            CCNative.xcocox_void_func_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETSCHEDULER, scheduler.hcore);
        }

        /** Gets the ActionManager associated with this director.
         * @since v2.0
         */
        ActionManager getActionManager()  { 
            return new ActionManager(CCNative.xcocox_long_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETACTIONMANAGER));
        }
        
        /** Sets the ActionManager associated with this director.
         * @since v2.0
         */
        void setActionManager(ActionManager actionManager){
            CCNative.xcocox_void_func_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETACTIONMANAGER, actionManager.hcore);
        }
        
        /** Gets the EventDispatcher associated with this director.
         * @since v3.0
         * @js NA
         */
        EventDispatcher getEventDispatcher() { 
            return new EventDispatcher(CCNative.xcocox_long_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETEVENTDISPATCHER));
        }
        
        /** Sets the EventDispatcher associated with this director.
         * @since v3.0
         * @js NA
         */
        void setEventDispatcher(EventDispatcher dispatcher){
            CCNative.xcocox_void_func_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRSETEVENTDISPATCHER, dispatcher.hcore);
        }

        /** Returns the Renderer associated with this director.
         * @since v3.0
         */
        Renderer getRenderer()  { 
             return new Renderer(CCNative.xcocox_long_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETRENDERER));
        }
        
        double getDeltaTime(){
            return CCNative.xcocox_get_double(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETDELTATIME);
        }
        
        /**
         *  Gets Frame Rate.
         * @js NA
         */
        double getFrameRate()  { 
            return CCNative.xcocox_get_double(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETFRAMERATE);
        }

        /** 
         * Clones a specified type matrix and put it to the top of specified type of matrix stack.
         * @js NA
         */
        void pushMatrix(MATRIX_STACK_TYPE type){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPUSHMATRIX, type);
        }

        /**
         * Clones a projection matrix and put it to the top of projection matrix stack.
         * @param index The index of projection matrix stack.
         * @js NA
         */
        void pushProjectionMatrix(int index){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPUSHPROJECTIONMATRIX, index);
        }

        /** Pops the top matrix of the specified type of matrix stack.
         * @js NA
         */
        void popMatrix(MATRIX_STACK_TYPE type){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPOPMATRIX, type);
        }

        /** Pops the top matrix of the projection matrix stack.
         * @param index The index of projection matrix stack.
         * @js NA
         */
        void popProjectionMatrix(int index){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRPOPPROJECTIONMATRIX, index);
        }

        /** Adds an identity matrix to the top of specified type of matrix stack.
         * @js NA
         */
        void loadIdentityMatrix(MATRIX_STACK_TYPE type){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRLOADIDENTITYMATRIX, type);
        }

        /** Adds an identity matrix to the top of projection matrix stack.
         * @param index The index of projection matrix stack.
         * @js NA
         */
        void loadProjectionIdentityMatrix(int index){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRLOADPROJECTIONIDENTITYMATRIX, index);
        }

        /**
         * Adds a matrix to the top of specified type of matrix stack.
         * 
         * @param type Matrix type.
         * @param mat The matrix that to be added.
         * @js NA
         */
        void loadMatrix(MATRIX_STACK_TYPE type, Mat4 mat){
            CCNative.xcocox_void_func_int_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRLOADMATRIX, type, mat.hcore);
        }

        /**
         * Adds a matrix to the top of projection matrix stack.
         *
         * @param mat The matrix that to be added.
         * @param index The index of projection matrix stack.
         * @js NA
         */
        void loadProjectionMatrix(Mat4 mat, int index){
            CCNative.xcocox_void_func_int_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRLOADPROJECTIONMATRIX, index, mat.hcore);
        }

        /**
         * Multiplies a matrix to the top of specified type of matrix stack.
         *
         * @param type Matrix type.
         * @param mat The matrix that to be multiplied.
         * @js NA
         */
        void multiplyMatrix(MATRIX_STACK_TYPE type, Mat4 mat){
            CCNative.xcocox_void_func_int_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRMULTIPLYMATRIX, type, mat.hcore);
        }

        /**
         * Multiplies a matrix to the top of projection matrix stack.
         *
         * @param mat The matrix that to be multiplied.
         * @param index The index of projection matrix stack.
         * @js NA
         */
        void multiplyProjectionMatrix(Mat4 mat, int index){
            CCNative.xcocox_void_func_int_long(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRMULTIPLYPROJECTIONMATRIX, index, mat.hcore);
        }

        /**
         * Gets the top matrix of specified type of matrix stack.
         * @js NA
         */
        Mat4 getMatrix(MATRIX_STACK_TYPE type){
            return new Mat4(CCNative.xcocox_long_int_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETMATRIX, type));
        }

        /**
         * Gets the top matrix of projection matrix stack.
         * @param index The index of projection matrix stack.
         * @js NA
         */
        Mat4 getProjectionMatrix(int index) {
            return new Mat4(CCNative.xcocox_long_int_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETPROJECTIONMATRIX, index));
        }

        /**
         * Clear all types of matrix stack, and add identity matrix to these matrix stacks.
         * @js NA
         */
        void resetMatrixStack(){
            CCNative.xcocox_void_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRRESETMATRIXSTACK);
        }

        /**
         * Init the projection matrix stack.
         * @param stackCount The size of projection matrix stack.
         * @js NA
         */
        void initProjectionMatrixStack(int stackCount){
            CCNative.xcocox_void_func_int(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRINITPROJECTIONMATRIXSTACK, stackCount);
        }

        /**
         * Get the size of projection matrix stack.
         * @js NA
         */
        int getProjectionMatrixStackSize(){
            return CCNative.xcocox_int_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRGETPROJECTIONMATRIXSTACKSIZE);
        }

        /**
         * returns the cocos2d thread id.
         Useful to know if certain code is already running on the cocos2d thread
         */

        /**
         * returns whether or not the Director is in a valid state
         */
        bool isValid() { 
            return CCNative.xcocox_int_func(hcore, CCNative.NATIVE_SYSCALL_ID.CC_DIRISVALID) != 0;
        }
    };
};
